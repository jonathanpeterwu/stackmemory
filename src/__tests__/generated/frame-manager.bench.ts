/**
 * Generated performance benchmark for FrameManager
 * Generated by TestingAgent
 */

import { bench, describe } from 'vitest';
import { FrameManager } from '../../core/context/index.js';
import Database from 'better-sqlite3';
import { join } from 'path';
import { mkdtempSync, rmSync } from 'fs';
import { tmpdir } from 'os';

describe('FrameManager performance', () => {
  let db: Database.Database;
  let frameManager: FrameManager;
  let tempDir: string;
  const projectId = 'bench-project';

  // Setup before benchmarks
  const setup = () => {
    tempDir = mkdtempSync(join(tmpdir(), 'bench-'));
    const dbPath = join(tempDir, 'bench.db');
    db = new Database(dbPath);
    frameManager = new FrameManager(db, projectId);
  };

  // Cleanup after benchmarks
  const cleanup = () => {
    if (db) db.close();
    if (tempDir) rmSync(tempDir, { recursive: true, force: true });
  };

  bench('createFrame execution time', () => {
    setup();
    
    frameManager.createFrame({
      type: 'benchmark',
      name: 'Performance Test Frame',
      inputs: { test: true, timestamp: Date.now() }
    });
    
    cleanup();
  });

  bench('getFrame execution time', () => {
    setup();
    
    // Pre-create frames for retrieval
    const frameIds: string[] = [];
    for (let i = 0; i < 100; i++) {
      frameIds.push(frameManager.createFrame({
        type: 'bench',
        name: `Frame ${i}`
      }));
    }
    
    // Benchmark frame retrieval
    const randomId = frameIds[Math.floor(Math.random() * frameIds.length)];
    frameManager.getFrame(randomId);
    
    cleanup();
  });

  bench('bulk frame creation (100 frames)', () => {
    setup();
    
    for (let i = 0; i < 100; i++) {
      frameManager.createFrame({
        type: 'bulk',
        name: `Bulk Frame ${i}`,
        inputs: {
          index: i,
          data: `Data for frame ${i}`.repeat(10)
        }
      });
    }
    
    cleanup();
  });

  bench('nested frame creation (10 levels deep)', () => {
    setup();
    
    let parentId = frameManager.createFrame({
      type: 'root',
      name: 'Root Frame'
    });
    
    for (let i = 0; i < 10; i++) {
      parentId = frameManager.createFrame({
        type: 'nested',
        name: `Level ${i + 1}`,
        parentFrameId: parentId
      });
    }
    
    cleanup();
  });

  bench('addEvent execution time', () => {
    setup();
    
    const frameId = frameManager.createFrame({
      type: 'events',
      name: 'Event Frame'
    });
    
    frameManager.addEvent(frameId, 'benchmark-event', {
      timestamp: Date.now(),
      data: 'Benchmark event data'
    });
    
    cleanup();
  });

  bench('bulk event addition (100 events)', () => {
    setup();
    
    const frameId = frameManager.createFrame({
      type: 'events',
      name: 'Event Frame'
    });
    
    for (let i = 0; i < 100; i++) {
      frameManager.addEvent(frameId, `event-${i}`, {
        index: i,
        timestamp: Date.now()
      });
    }
    
    cleanup();
  });

  bench('getEvents execution time (100 events)', () => {
    setup();
    
    const frameId = frameManager.createFrame({
      type: 'events',
      name: 'Event Frame'
    });
    
    // Pre-populate events
    for (let i = 0; i < 100; i++) {
      frameManager.addEvent(frameId, `event-${i}`, {
        index: i
      });
    }
    
    // Benchmark retrieval
    frameManager.getEvents(frameId);
    
    cleanup();
  });

  bench('closeFrame execution time', () => {
    setup();
    
    const frameId = frameManager.createFrame({
      type: 'close',
      name: 'Frame to Close'
    });
    
    frameManager.closeFrame(frameId);
    
    cleanup();
  });

  bench('database transaction with multiple operations', () => {
    setup();
    
    // Simulate complex transaction
    const parentId = frameManager.createFrame({
      type: 'transaction',
      name: 'Transaction Parent'
    });
    
    for (let i = 0; i < 5; i++) {
      const childId = frameManager.createFrame({
        type: 'child',
        name: `Child ${i}`,
        parentFrameId: parentId
      });
      
      frameManager.addEvent(childId, 'created', { index: i });
      frameManager.addEvent(parentId, 'child-added', { childId });
    }
    
    frameManager.closeFrame(parentId);
    
    cleanup();
  });

  bench('concurrent frame operations simulation', async () => {
    setup();
    
    const promises: Promise<string>[] = [];
    
    for (let i = 0; i < 10; i++) {
      promises.push(
        Promise.resolve(
          frameManager.createFrame({
            type: 'concurrent',
            name: `Concurrent Frame ${i}`
          })
        )
      );
    }
    
    await Promise.all(promises);
    
    cleanup();
  });

  bench('large payload handling (1MB)', () => {
    setup();
    
    const largeData = 'x'.repeat(1024 * 1024); // 1MB of data
    
    frameManager.createFrame({
      type: 'large',
      name: 'Large Payload Frame',
      inputs: {
        data: largeData
      }
    });
    
    cleanup();
  });

  bench('frame hierarchy traversal (100 frames)', () => {
    setup();
    
    // Create hierarchy
    const rootId = frameManager.createFrame({
      type: 'root',
      name: 'Root'
    });
    
    const childIds: string[] = [];
    for (let i = 0; i < 10; i++) {
      const childId = frameManager.createFrame({
        type: 'child',
        name: `Child ${i}`,
        parentFrameId: rootId
      });
      childIds.push(childId);
      
      // Add grandchildren
      for (let j = 0; j < 9; j++) {
        frameManager.createFrame({
          type: 'grandchild',
          name: `Grandchild ${i}-${j}`,
          parentFrameId: childId
        });
      }
    }
    
    // Benchmark traversal (would need actual traversal method)
    childIds.forEach(id => frameManager.getFrame(id));
    
    cleanup();
  });

  bench('memory usage with 1000 frames', () => {
    setup();
    
    const initialMemory = process.memoryUsage().heapUsed;
    
    for (let i = 0; i < 1000; i++) {
      frameManager.createFrame({
        type: 'memory',
        name: `Memory Test Frame ${i}`,
        inputs: {
          index: i,
          data: `Some data for frame ${i}`
        }
      });
    }
    
    const finalMemory = process.memoryUsage().heapUsed;
    const memoryUsed = finalMemory - initialMemory;
    
    // Log memory usage (for monitoring)
    if (memoryUsed > 50 * 1024 * 1024) { // 50MB threshold
      console.warn(`High memory usage: ${(memoryUsed / 1024 / 1024).toFixed(2)}MB`);
    }
    
    cleanup();
  });
});