/**
 * Generated integration test suite for Linear API module
 * Generated by TestingAgent
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { LinearSyncService } from '../../integrations/linear/sync-service.js';
import { LinearAuth } from '../../integrations/linear/auth.js';
import { LinearTaskManager } from '../../features/tasks/linear-task-manager.js';
import Database from 'better-sqlite3';
import { join } from 'path';
import { mkdtempSync, rmSync } from 'fs';
import { tmpdir } from 'os';

describe('Linear Integration', () => {
  let syncService: LinearSyncService;
  let taskStore: LinearTaskManager;
  let db: Database.Database;
  let tempDir: string;
  const projectId = 'test-project';

  // Mock Linear API responses
  const mockLinearClient = {
    viewer: vi.fn().mockResolvedValue({ 
      id: 'user-123', 
      name: 'Test User' 
    }),
    teams: vi.fn().mockResolvedValue({
      nodes: [
        { id: 'team-1', name: 'Engineering', key: 'ENG' },
        { id: 'team-2', name: 'Design', key: 'DES' }
      ]
    }),
    issues: vi.fn().mockResolvedValue({
      nodes: [
        {
          id: 'issue-1',
          identifier: 'ENG-123',
          title: 'Fix authentication bug',
          description: 'Users cannot log in with SSO',
          state: { name: 'In Progress' },
          priority: 2,
          assignee: { id: 'user-123', name: 'Test User' },
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        },
        {
          id: 'issue-2',
          identifier: 'ENG-124',
          title: 'Improve performance',
          description: 'Optimize database queries',
          state: { name: 'Todo' },
          priority: 3,
          assignee: null,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        }
      ]
    }),
    issue: vi.fn().mockImplementation((id: string) => {
      return Promise.resolve({
        id,
        update: vi.fn().mockResolvedValue({ success: true })
      });
    })
  };

  beforeEach(() => {
    // Setup integration test environment
    tempDir = mkdtempSync(join(tmpdir(), 'linear-test-'));
    const dbPath = join(tempDir, 'test.db');
    db = new Database(dbPath);
    
    taskStore = new LinearTaskManager(db, projectId);
    
    // Mock Linear client
    vi.spyOn(LinearAuth, 'createClient').mockResolvedValue(mockLinearClient as any);
    
    syncService = new LinearSyncService(taskStore, projectId);
  });

  afterEach(() => {
    // Cleanup integration test environment
    vi.clearAllMocks();
    if (db) db.close();
    if (tempDir) rmSync(tempDir, { recursive: true, force: true });
  });

  it('should initialize Linear module', async () => {
    // Act
    const module = await import('../../integrations/linear/index.js');

    // Assert
    expect(module).toBeDefined();
    expect(module.LinearAuth).toBeDefined();
    expect(module.LinearSyncService).toBeDefined();
  });

  it('should export expected interfaces from Linear', () => {
    // Act
    const exports = Object.keys(require('../../integrations/linear/index.js'));

    // Assert
    expect(exports.length).toBeGreaterThan(0);
    expect(exports).toContain('LinearAuth');
    expect(exports).toContain('LinearSyncService');
  });

  it('should authenticate with Linear API', async () => {
    // Arrange
    process.env.LINEAR_API_KEY = 'test-api-key';

    // Act
    const client = await LinearAuth.createClient();
    const viewer = await client.viewer();

    // Assert
    expect(viewer).toBeDefined();
    expect(viewer.id).toBe('user-123');
    expect(viewer.name).toBe('Test User');
  });

  it('should sync issues from Linear to local tasks', async () => {
    // Arrange
    process.env.LINEAR_API_KEY = 'test-api-key';

    // Act
    const result = await syncService.syncFromLinear();

    // Assert
    expect(result.success).toBe(true);
    expect(result.synced).toBe(2);
    expect(result.errors).toHaveLength(0);
    
    // Verify tasks were created
    const tasks = taskStore.listTasks();
    expect(tasks).toHaveLength(2);
    expect(tasks[0].title).toBe('Fix authentication bug');
    expect(tasks[0].metadata?.linearId).toBe('issue-1');
  });

  it('should handle Linear API errors gracefully', async () => {
    // Arrange
    mockLinearClient.issues.mockRejectedValueOnce(new Error('API rate limit exceeded'));

    // Act
    const result = await syncService.syncFromLinear();

    // Assert
    expect(result.success).toBe(false);
    expect(result.synced).toBe(0);
    expect(result.errors).toHaveLength(1);
    expect(result.errors[0]).toContain('rate limit');
  });

  it('should update Linear issue when local task is modified', async () => {
    // Arrange
    const taskId = taskStore.createTask({
      title: 'Local task',
      status: 'todo',
      metadata: { linearId: 'issue-1' }
    });
    
    taskStore.updateTask(taskId, {
      status: 'done'
    });

    // Act
    const result = await syncService.syncToLinear();

    // Assert
    expect(result.success).toBe(true);
    expect(result.synced).toBe(1);
    expect(mockLinearClient.issue).toHaveBeenCalledWith('issue-1');
  });

  it('should handle bidirectional sync conflicts', async () => {
    // Arrange
    // Create local task
    const taskId = taskStore.createTask({
      title: 'Conflicting task',
      status: 'in-progress',
      metadata: { 
        linearId: 'issue-1',
        lastSyncedAt: new Date(Date.now() - 3600000).toISOString() // 1 hour ago
      }
    });
    
    // Simulate Linear having a newer update
    mockLinearClient.issues.mockResolvedValueOnce({
      nodes: [{
        id: 'issue-1',
        identifier: 'ENG-123',
        title: 'Updated title from Linear',
        state: { name: 'Done' },
        updatedAt: new Date().toISOString() // Now
      }]
    });

    // Act
    const result = await syncService.handleSyncConflicts();

    // Assert
    expect(result.conflicts).toHaveLength(1);
    expect(result.resolved).toBe(1);
    
    // Verify Linear version won (newer)
    const task = taskStore.getTask(taskId);
    expect(task?.title).toBe('Updated title from Linear');
    expect(task?.status).toBe('done');
  });

  it('should batch sync multiple issues efficiently', async () => {
    // Arrange
    const largeIssueBatch = {
      nodes: Array.from({ length: 100 }, (_, i) => ({
        id: `issue-${i}`,
        identifier: `ENG-${i}`,
        title: `Issue ${i}`,
        state: { name: 'Todo' },
        priority: 1,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }))
    };
    mockLinearClient.issues.mockResolvedValueOnce(largeIssueBatch);

    // Act
    const startTime = Date.now();
    const result = await syncService.syncFromLinear({ batchSize: 10 });
    const duration = Date.now() - startTime;

    // Assert
    expect(result.success).toBe(true);
    expect(result.synced).toBe(100);
    expect(duration).toBeLessThan(5000); // Should complete in under 5 seconds
    
    // Verify all tasks were created
    const tasks = taskStore.listTasks();
    expect(tasks).toHaveLength(100);
  });

  it('should respect rate limits when syncing', async () => {
    // Arrange
    let callCount = 0;
    mockLinearClient.issues.mockImplementation(() => {
      callCount++;
      if (callCount > 5) {
        return Promise.reject(new Error('Rate limit exceeded'));
      }
      return Promise.resolve({ nodes: [] });
    });

    // Act
    const result = await syncService.syncWithRateLimiting({ 
      maxRequestsPerMinute: 5 
    });

    // Assert
    expect(result.throttled).toBe(true);
    expect(callCount).toBeLessThanOrEqual(6);
  });

  it('should map Linear states to local task statuses correctly', () => {
    // Arrange
    const stateMappings = [
      { linear: 'Todo', local: 'todo' },
      { linear: 'In Progress', local: 'in-progress' },
      { linear: 'Done', local: 'done' },
      { linear: 'Canceled', local: 'cancelled' },
      { linear: 'Backlog', local: 'todo' }
    ];

    // Act & Assert
    stateMappings.forEach(mapping => {
      const result = syncService.mapLinearStateToStatus(mapping.linear);
      expect(result).toBe(mapping.local);
    });
  });

  it('should handle webhook events from Linear', async () => {
    // Arrange
    const webhookPayload = {
      action: 'update',
      type: 'Issue',
      data: {
        id: 'issue-1',
        title: 'Updated via webhook',
        state: { name: 'Done' }
      }
    };

    // Act
    const result = await syncService.handleWebhook(webhookPayload);

    // Assert
    expect(result.processed).toBe(true);
    expect(result.action).toBe('update');
    
    // Verify task was updated
    const tasks = taskStore.listTasks({ metadata: { linearId: 'issue-1' } });
    expect(tasks[0]?.title).toBe('Updated via webhook');
  });

  it('should clean up orphaned local tasks after Linear deletion', async () => {
    // Arrange
    // Create local tasks with Linear IDs
    const task1 = taskStore.createTask({
      title: 'Task 1',
      metadata: { linearId: 'issue-1' }
    });
    const task2 = taskStore.createTask({
      title: 'Task 2',
      metadata: { linearId: 'issue-deleted' }
    });
    
    // Mock Linear to only return issue-1
    mockLinearClient.issues.mockResolvedValueOnce({
      nodes: [{
        id: 'issue-1',
        identifier: 'ENG-123',
        title: 'Task 1',
        state: { name: 'Todo' },
        updatedAt: new Date().toISOString()
      }]
    });

    // Act
    const result = await syncService.cleanupOrphanedTasks();

    // Assert
    expect(result.removed).toBe(1);
    expect(taskStore.getTask(task1)).toBeDefined();
    expect(taskStore.getTask(task2)).toBeUndefined();
  });
});